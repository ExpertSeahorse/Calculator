import tkinter as tk
from CalculatorMethods import *
from CalculatorMethods import expression_converter
# noinspection PyUnresolvedReferences
import math
# ^^^ Don't remove, used in eval() expressions


class CalcMenu:
    """
    Creates the master class and main menu for the calculator
    """
    def __init__(self, master):
        self.master = master
        self.master.title("Calculator GUI")

        # Creates the Header label
        self.label = tk.Label(master, text="Choose an operation.")
        self.label.grid(columnspan=2, sticky=tk.W)

        button_parts = [("math_button", "Basic Math", lambda: self.router(1), 1, 0, 1),
                        ("stat_button", "Stats", lambda: self.router(3), 1, 1, 1),
                        ("man_graph_button", "Manual Graph", lambda:self.router(4), 2, 0, 1),
                        ("coord_graph_button", "Coord Point Graph", lambda:self.router(5), 2, 1, 1),
                        ("equation_graph_button", "Equation Graph", lambda:self.router(6), 3, 0, 1),
                        ("quit_button", "Quit", master.quit, 3, 1, 1)]
        # for the information above...
        for name, label, func, row, col, colspan in button_parts:
            # if colspan == 2, wid = 40, else wid = 20
            wid = 40 if colspan == 2 else 20
            # Creates the menu buttons
            self.name = tk.Button(master, text=label, width=wid, command=func)
            self.name.grid(row=row, column=col, columnspan=colspan)

    def router(self, num):
        """
        Routes opens the designated window for the user
        :param num:
        :return:
        """
        self.newWindow = tk.Toplevel(self.master)
        if num == 1:
            self.app = FiveFunc(self.newWindow)
        elif num == 3:
            self.app = StatFunc(self.newWindow)
        elif num == 4:
            self.app = ManGraph(self.newWindow)
        elif num == 5:
            self.app = TupGraph(self.newWindow)
        elif num == 6:
            self.app = EqGraph(self.newWindow)
########################################################################################################################


class FiveFunc:
    """
    Runs basic math functions (+,-,x,/,trig,%)
    """
    def __init__(self, master):
        self.title = tk.Label(master, text="Your Expression:").pack()

        self.entry = tk.Entry(master)
        self.entry.bind("<Return>", self.evaluate)
        self.entry.pack()

        self.res = tk.Label(master)
        self.res.pack()

    def evaluate(self, event):
        """
        Finds the result of the equation in the entry field and displays it in the res(ult) field
        :param event:
        """
        self.res.configure(text="Result: " + str(eval(expression_converter(self.entry.get()))))
########################################################################################################################


class StatFunc:
    def __init__(self, master):
        # Create Label
        self.ent_lab = tk.Label(master, text="Enter the list of numbers, separated by commas")
        self.ent_lab.pack()

        # Create entry field for array
        self.list_entry = tk.Entry(master)
        self.list_entry.bind("<Return>", self.stat_runner)
        self.list_entry.pack()

        # Create Result field
        self.res = tk.Label(master)
        self.res.pack()

    def stat_runner(self, event):
        # Returns all the variables calculated by stats method
        # Passes a list generated by getting the string from the entry field, splitting the string into an array,
        # And converting all of the entries into floats
        avg, numsum, numsum2, sam_std, pop_std, count, minimum, med, maximum \
            = stats_onevar(list(map(float, (str(self.list_entry.get())).split(','))))

        # Show the result in the result label
        self.res.config(text="The average:" + str(avg) + "\n" +
                             "The sum: " + str(numsum) + "\n" +
                             "The sum of num^2: " + str(numsum2) + "\n" +
                             "The sample standard deviation: " + str(sam_std) + "\n" +
                             "The population standard deviation: " + str(pop_std) + "\n" +
                             "The n: " + str(count) + "\n" +
                             "The minimum: " + str(minimum) + "\n" +
                             "The median: " + str(med) + "\n" +
                             "The maximum: " + str(maximum), justify=tk.LEFT)


########################################################################################################################


class ManGraph:
    def __init__(self, master):
        # Creates the title
        self.title = tk.Label(master, text="Manual Graphing Interface")
        self.title.grid(columnspan=2, sticky=tk.N)

        field_list = [("x_tit_lab", "Enter the title for the x-axis", "x_title"),
                      ("x_label", "Enter the x-values separated by commas: ", "x_entry"),
                      ("y_tit_lab", "Enter the title for the y-axis", "y_title"),
                      ("y_label", "Enter the y-values separated by commas: ", "y_entry"),
                      ("x_step", 'Enter the tick spacing on the x-axis', "x_step_entry"),
                      ("y_step", 'Enter the tick spacing on the y-axis', "y_step_entry"),
                      ("graph_type", "Enter the type of graph: ", "graph_entry")]
        self.new_list = []
        r = 1
        # for the entries in the list...
        for lab_name, lab_text, ent_name in field_list:
            # Create the labels
            self.lab_name = tk.Label(master, text=lab_text)
            self.lab_name.grid(row=r, column=0)

            # And make an Entry field
            self.ent_name = tk.Entry(master, width=30)
            self.ent_name.bind("<Return>", self.db_converter)
            self.ent_name.grid(row=r, column=1)
            self.new_list.append(self.ent_name)
            r += 1

        # kde and hexbin don't work because I don't know how to use them
        self.options = tk.Label(master, text="line\t: line plot\t\tbar\t: vertical bar plot\n"
                                "barh\t: horizontal bar plot\thist\t: histogram\n"
                                "box\t: box plot\t\t\tkde\t: Kernel Density Estimation plot\n"
                                "area\t: area plot\t\tpie\t: pie plot\n"                      
                                "scatter\t: scatter plot\t\thexbin\t: hexbin plot", justify=tk.LEFT)
        self.options.grid(row=r, columnspan=2, rowspan=5)

    def db_converter(self, event):
        # gets the input out of the entry field, forces it into a string, splits it into a list,
        # then tries to map all of the list entries into a float: If fail, keeps the values as strings
        try:
            x_values = list(map(float, (str(self.new_list[1].get())).split(',')))
        except ValueError:
            x_values = str(self.new_list[1].get()).split(',')
        try:
            y_values = list(map(float, (str(self.new_list[3].get())).split(',')))
        except ValueError:
            y_values = str(self.new_list[1].get()).split(',')

        x_title = self.new_list[0].get()
        y_title = self.new_list[2].get()
        x_step = self.new_list[4].get()
        y_step = self.new_list[5].get()
        kind = self.new_list[6].get()
        grd = True

        if not x_step:
            x_step = None
        if not y_step:
            y_step = None
        if not x_step and not y_step:
            grd = False

        db = database([x_values, y_values], [x_title, y_title])
        grapher(db=db, xstep=x_step, ystep=y_step, strng=kind, grid=grd)
########################################################################################################################


class TupGraph:
    def __init__(self, master):
        # Creates the label
        self.label = tk.Label(master, text="Enter the coordinate points: \"###,### ; ###,###\"").pack()

        # Creates the input field
        self.input = tk.Entry(master)
        self.input.bind("<Return>", self.db_converter)
        self.input.pack()

    def db_converter(self, event):
        """
        Digests the input string into a list of tuples for the coordinate points
        :param event:
        :return:
        """
        # Splits the arr on the semicolon to separate the pairs
        arr = str(self.input.get()).strip().split(';')
        for i, entry in enumerate(arr):
            # Splits the pairs into x and y
            new_entry = tuple(map(float, entry.strip().split(",")))
            # Adds the new pairs back into the array
            arr[i] = new_entry
        tuple_grapher(arr)
########################################################################################################################


class EqGraph:
    def __init__(self, master):
        # Initializes entry list
        # Creates Grid and title for window
        self.label = tk.Label(master, text="Equation Graphing")
        self.label.grid(columnspan=2, sticky=tk.N)

        entry_list = [("input", "", "Enter the equation", "a"),
                      ("win_min", "-10", "Enter the min x-value", "b"),
                      ("win_max", "10", "Enter the max x-value", "c"),
                      ("x_step", "1", "Enter the x-step", "d")]
        row = 1
        self.input_list = []
        # Creates Entry fields and their Labels based on list above
        for a, def_txt, lab_txt, lab_name in entry_list:
            self.lab_name = tk.Label(master, text=lab_txt).grid(row=row)

            self.a = tk.Entry(master)
            self.a.bind("<Return>", self.eq_converter)
            self.a.insert(tk.END, def_txt)
            self.a.grid(row=row, column=1)
            self.input_list.append(self.a)
            row += 1
        # Error message label
        self.res = tk.Label(master)
        self.res.grid(row=row+1, columnspan=2)

    def eq_converter(self, event):
        # get input
        self.inputs = [entry.get() for entry in self.input_list]
        self.input_list = list(map(str, self.inputs))

        # runs the eq graphing func, but if any errors will return into err var
        err = equation_processor(*self.inputs)
        self.res.config(text=err)


if __name__ == '__main__':
    root = tk.Tk()
    app = CalcMenu(root)
    root.mainloop()
